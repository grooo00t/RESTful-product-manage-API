#1 [django] N+1 쿼리란 무엇이며 이를 해결하기 위해선 어떻게 해야 하는지 작성하세요

# N+1 쿼리
- 데이터베이스에서 N개의 레코드를 가져오는 1개의 쿼리를 실행한 후, 각 레코드의 관련 데이터를 가져오기 위해 추가로 N개의 쿼리를 실행하는 상황

# N+1 쿼리를 해결방안
- select_related : ForeignKey와 같은 one-to-many 관계에서 JOIN 쿼리를 사용하여 관련 데이터를 가져옴
- prefetch_related : many-to-many 관계나 역참조에서 사용. 별도의 쿼리로 관련 객체를 미리 가져온 후 Python 에서 JOIN 진행
- annotate : annotate 는 SQL 의 JOIN 과 집계 함수를 사용하여 관련 테이블의 데이터를 현재 쿼리에 포함 시켜 n+1 쿼리를 방지

#2 [django] to_representation, to_internal_value 메서드는 언제 사용되며, 어떤 경우에 재정의 하는지 서술하세요

# to_representation
- 모델 인스턴스나 Python 네이티브 데이터 타입을 JSON과 같은 직렬화된 형태로 변환할 때 사용됨
- 호출 시점
  - serializer.data 속성에 접근할 때

# to_internal_value
- 직렬화된 데이터(JSON 등)를 Python 네이티브 데이터 타입으로 역직렬화할 때 사용됨
- 호출 시점
  - serializer.validated_data에 접근하기 전
  - serializer.save() 메서드가 호출될 때
  - serializer.is_valid() 메서드가 호출될 때



#3 [mysql] 대규모 데이터가 저장된 테이블에서 검색 성능을 최적화하기 위한 인덱스 설계 방법을 설명하고 필요하다면 복합 인덱스를 포함한 예시를 제시하고 인덱스 사용의 단점이나 주의사항도 설명하세요

# 인덱스 설계 방법
1. 쿼리 패턴 분석
  - 자주 실행되는 쿼리를 식별
  - WHERE, JOIN, ORDER BY, GROUP BY 절에서 사용되는 컬럼 파악

2. 인덱스 유형 선택
  - B-Tree 인덱스 : 대부분의 검색 조건에 적합
  - Hash 인덱스 : 등호(=) 비교에만 효과적
  - Full-Text 인덱스 : 텍스트 검색에 적합

3. 인덱스 설계
  - 조건절에서 자주 사용되는 컬럼에 인덱스 생성
  - 단일 컬럼 인덱스
    - 조건절에서 하나의 컬럼만 사용되는 경우
  - 복합 인덱스
    - 여러 컬럼에 대한 검색 조건이 있는 경우 복합 인덱스 생성
    - 등호 조건, 범위 조건, 정렬이나 그룹화에 사용되는 컬럼 순으로 복합 인덱스 생성
  - 상황에 따라 커버링 인덱스(쿼리를 충족시키는 데 필요한 모든 데이터를 갖고 있는 인덱스) 사용

# 인덱스 설계 주의사항
- 저장 공간 증가
  - 인덱스 생성 시 저장 공간이 증가
  - 대규모 테이블에서는 인덱스가 원본 테이블보다 더 많은 공간을 차지할 수 있음

- 쓰기 성능 저하
  - INSERT, UPDATE, DELETE 작업 시 인덱스도 함께 업데이트해야 하므로 쓰기 성능이 저하될 수 있음 (복합 인덱스가 많을수록 영향이 커짐)

- 인덱스 미사용 상황 확인 필요
  - 인덱스 컬럼에 함수 적용 (ex. WHERE DATE_FORMAT(created_at, '%Y-%m-%d') = '2025-01-01')
  - string 조건이 걸려있는 컬럼에 integer 조건으로 검색하는 암시적 형변환
  - 부정 조건



#4 [mysql] 대규모 데이터를 다룰 때 쿼리 성능을 최적화하는 방법을 설명하세요. 실행 계획(Execution Plan)을 사용하여 쿼리 성능을 개선할 수 있는 방법을 구체적으로 설명하고 자주 발생하는 쿼리 최적화의 병목을 해결할 수 있는 방안을 제시하세요

# 실행 계획(Execution Plan)을 활용한 쿼리 성능 개선
1. EXPLAIN 명령어 활용 기본
  - EXPLAIN 명령어로 쿼리의 실행 계획 확인
  - EXPLAIN FORMAT=JSON으로 더 상세한 정보 확인
  - 실행 계획 분석을 통해 비효율적인 부분 식별

2. 실행 계획 주요 컬럼 분석
  - select_type: 쿼리 유형 확인 (SIMPLE, PRIMARY, SUBQUERY 등)
  - type: 테이블 접근 방식 확인 (const, eq_ref, ref, range, index, ALL 등)
  - possible_keys/key: 사용 가능/실제 사용된 인덱스 확인
  - rows: 검색해야 할 예상 행 수 확인
  - Extra: 추가 정보 확인 (Using index, Using filesort, Using temporary 등)

3. 실행 계획 기반 최적화 전략
  - 테이블 접근 방식 개선 (ALL을 range/ref/eq_ref/const로 개선)
  - 조인 순서 최적화 (작은 결과셋 먼저 처리)
  - 불필요한 임시 테이블 및 파일 정렬 제거
  - 인덱스 사용 패턴 최적화

# 자주 발생하는 쿼리 최적화 병목 및 해결 방안
1. 전체 테이블 스캔(Full Table Scan) 문제
  - 병목 현상: type이 ALL로 표시, 대용량 테이블 전체 스캔
  - 해결 방안:
    - 적절한 인덱스 생성
    - 복합 인덱스 활용
    - 쿼리 조건 재검토

2. 비효율적인 조인 연산
  - 병목 현상: 대용량 테이블 간 조인, rows 값이 매우 큼
  - 해결 방안:
    - 조인 순서 최적화 (STRAIGHT_JOIN 힌트 활용)
    - 조인 컬럼에 인덱스 생성
    - 배치 처리 도입

3. 인덱스 사용 불가 조건
  - 병목 현상: 인덱스가 있지만 사용되지 않음
  - 해결 방안:
    - 함수 사용 피하기 (컬럼에 직접 조건 적용)
    - 암시적 형변환 방지 (데이터 타입 일치)
    - 전문 검색 인덱스 활용 (FULLTEXT)
    - 계산된 컬럼 인덱싱 (GENERATED COLUMNS)

4. 정렬 및 그룹화 작업의 비효율성
  - 병목 현상: Using filesort, Using temporary 표시
  - 해결 방안:
    - 정렬/그룹화 컬럼에 맞는 인덱스 생성
    - ORDER BY와 GROUP BY 컬럼 일치시키기
    - LIMIT 활용하여 결과 제한

5. 서브쿼리 비효율성
  - 병목 현상: 상관 서브쿼리가 행마다 실행됨
  - 해결 방안:
    - 조인으로 변환
    - EXISTS 활용
    - 임시 테이블 활용

6. 대용량 데이터 처리 병목
  - 병목 현상: 메모리 부족, 락 경합, 네트워크 병목
  - 해결 방안:
    - 데이터 파티셔닝
    - 페이지네이션 구현
    - 스트리밍 처리

7. 캐싱 관련 병목
  - 병목 현상: 동일 쿼리 반복 실행, 자주 변경되지 않는 데이터 반복 조회
  - 해결 방안:
    - 애플리케이션 레벨 캐싱 (Redis, Memcached)
    - 구체화된 뷰(Materialized Views) 구현

8. 트랜잭션 및 락 경합 병목
  - 병목 현상: 장시간 실행 트랜잭션, 데드락, 읽기/쓰기 충돌
  - 해결 방안:
    - 트랜잭션 최적화 (필수 작업만 포함)
    - 적절한 격리 수준 설정
    - 낙관적 락(Optimistic Locking) 구현
    - 행 수준 락 최소화

9. 메모리 관련 병목
  - 병목 현상: 정렬/그룹화/조인 시 메모리 부족
  - 해결 방안:
    - 메모리 관련 설정 최적화
    - 인덱스를 통한 메모리 사용 최적화
    - 쿼리 분할(JOIN 없이 쿼리를 분할)로 메모리 사용 감소

10. 스키마 설계 관련 병목
  - 병목 현상: 정규화/비정규화 불균형, 부적절한 데이터 타입
  - 해결 방안:
    - 적절한 데이터 타입 선택
    - 수직 분할(Vertical Partitioning)
    - 계산된 컬럼 (GENERATED COLUMNS) 추가
